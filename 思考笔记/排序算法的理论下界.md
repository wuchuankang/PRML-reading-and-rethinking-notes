## 排序算法的理论下界

+ 对于已知的排序算法，其时间复杂度最快的是$O(n\log n)$，能否有更好的算法，其时间复杂度更少呢？

  答案是：没有的

+ 我们来构造一个通用的模型，来说明对于所有的排序算法都适用，这样，这个模型的下界就是所有排序算法的下界。排序算法是建立在比较的基础上的，而比较所通用的模型就是决策树。决策树实际上反映了信息论中信息的量化，信息量的定义就是:$I=-\log_2 p(x) $。通过决策树，就可以理解为什么信息量的表达式是以2为基底的对数函数了。假设我们对$n$个数进行排序，我们通过构建决策树来进行，每一个叶子节点就是就是排序的一种结果，那么有多少种排列就有多少个叶子节点，总共有$n!$个排序，那么就有$n!​$个叶子节点。参见下图：

  ![459dce42dafbd9bc6771a55e383f0b49_hd](/home/wck/Documents/笔记/459dce42dafbd9bc6771a55e383f0b49_hd.jpg)

+ 由于决策树是二叉树，所以该树的高度至少是$\log_2 n!$，而树的高度就是排序算法比较的次数，对于$n!$有斯特林近似公式：
  $$
  n!=\sqrt{2\pi n}{(\frac{n}{e})}^n(1+O(1/n))\\
  \Rightarrow \log_2 n!=n\log_2 n- n\log_2 e+\log_2 \sqrt{2\pi n} (1+O(1/n))=\Omega(n\log n)   \tag{1}
  $$
  不用斯特林公式，一样可以推导出结果：
  $$
  \begin{aligned}
  \log_2 n!
  &=\log_2 n+\log_2 (n-1)+...+\log_2 1\\
  &\geq \log_2 n + \log_2 (n-1) +... +\log_2 (n/2)\\
  &\geq(n/2)\log_2(n/2)\\
  &=(n/2)\log_2 n-n/2\\
  &=\Omega(n\log n)
  \end{aligned}   \tag{2}
  $$
  这是所有用比较的排序算法最坏的情况的下界，即所有以比较作为排序的算法的时间复杂度都不能低于$O(n)$。